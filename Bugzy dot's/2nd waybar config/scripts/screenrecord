#!/usr/bin/env bash

RECORDINGS_DIR="$HOME/Videos/Recordings"
PID_FILE="/tmp/wf-recorder.pid"
STATUS_FILE="/tmp/wf-recorder.status"
LOG_FILE="/tmp/wf-recorder.log"

mkdir -p "$RECORDINGS_DIR"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

show_help() {
    cat << EOF
Screen Recording Script for wf-recorder

Usage: screenrec [OPTION]

OPTIONS:
    region      Record a selected region of the screen
    monitor     Record entire monitor/output
    window      Record a specific window
    status      Show recording status (for waybar integration)
    stop        Stop current recording
    help        Show this help message

EXAMPLES:
    screenrec region        # Select area to record
    screenrec monitor       # Record full screen
    screenrec window        # Select window to record
    screenrec status        # Get status for waybar
    screenrec stop          # Stop recording

Files are saved to: $RECORDINGS_DIR
EOF
}

generate_filename() {
    local prefix="$1"
    local timestamp
    timestamp=$(date +"%Y%m%d_%H%M%S")
    echo "${RECORDINGS_DIR}/${prefix}_${timestamp}.mp4"
}

get_active_audio_monitor() {
    local default_sink
    default_sink=$(pactl get-default-sink 2>/dev/null)
    if [[ -z "$default_sink" ]]; then
        default_sink=$(pactl info | grep 'Default Sink:' | awk '{print $3}')
    fi
    if [[ -z "$default_sink" ]]; then
        echo ""
        return 1
    fi
    echo "${default_sink}.monitor"
}

is_recording() {
    [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null
}

start_recording() {
    local geometry="$1"
    local filename="$2"
    local description="$3"

    if is_recording; then
        echo -e "${RED}Recording already in progress!${NC}"
        exit 1
    fi

    # Get the active audio monitor
    local audio_monitor
    audio_monitor=$(get_active_audio_monitor)
    if [[ -z "$audio_monitor" ]]; then
        echo -e "${RED}Could not determine active audio output monitor!${NC}"
        exit 1
    fi

    echo -e "${GREEN}Starting $description...${NC}"
    echo -e "${BLUE}Output file: $filename${NC}"
    echo -e "${BLUE}Audio source: $audio_monitor${NC}"

    echo "recording" > "$STATUS_FILE"
    echo "$(date +%s)" >> "$STATUS_FILE"
    echo "$description" >> "$STATUS_FILE"
    echo "$filename" >> "$STATUS_FILE"

    if [[ -n "$geometry" ]]; then
        wf-recorder --audio="$audio_monitor" -g "$geometry" -f "$filename" --codec=libx264 --pixel-format=yuv420p > "$LOG_FILE" 2>&1 &
    else
        wf-recorder --audio="$audio_monitor" -f "$filename" --codec=libx264 --pixel-format=yuv420p > "$LOG_FILE" 2>&1 &
    fi

    local recorder_pid=$!
    echo "$recorder_pid" > "$PID_FILE"

    sleep 1
    if ! kill -0 "$recorder_pid" 2>/dev/null; then
        echo -e "${RED}Failed to start recording. Check $LOG_FILE for details.${NC}"
        cleanup_files
        exit 1
    fi

    echo -e "${GREEN}Recording started successfully!${NC}"
    echo -e "${YELLOW}Use 'screenrec stop' to stop recording${NC}"
}

cleanup_files() {
    rm -f "$PID_FILE" "$STATUS_FILE"
}

record_region() {
    echo -e "${BLUE}Select the region to record...${NC}"

    if ! command -v slurp &> /dev/null; then
        echo -e "${RED}Error: slurp is required for region selection${NC}"
        echo -e "${YELLOW}Install with: sudo pacman -S slurp${NC}"
        exit 1
    fi

    local geometry
    geometry=$(slurp 2>/dev/null)

    if [[ -z "$geometry" ]]; then
        echo -e "${RED}Region selection cancelled${NC}"
        exit 1
    fi

    local filename
    filename=$(generate_filename "region")

    start_recording "$geometry" "$filename" "region recording"
}

record_monitor() {
    echo -e "${BLUE}Available outputs:${NC}"

    if command -v wlr-randr &> /dev/null; then
        wlr-randr | grep -E "^[A-Z]" | nl -v0
        echo
        read -p "Select output number (0 for all): " output_num

        if [[ "$output_num" == "0" ]]; then
            local filename
            filename=$(generate_filename "fullscreen")
            start_recording "" "$filename" "full screen recording"
        else
            local output_name
            output_name=$(wlr-randr | grep -E "^[A-Z]" | sed -n "$((output_num + 1))p" | awk '{print $1}')

            if [[ -n "$output_name" ]]; then
                local filename
                filename=$(generate_filename "monitor_${output_name}")
                start_recording "" "$filename" "monitor ($output_name) recording"
            else
                echo -e "${RED}Invalid selection${NC}"
                exit 1
            fi
        fi
    else
        echo -e "${YELLOW}wlr-randr not found, recording all outputs${NC}"
        local filename
        filename=$(generate_filename "fullscreen")
        start_recording "" "$filename" "full screen recording"
    fi
}

record_window() {
    if ! command -v slurp &> /dev/null; then
        echo -e "${RED}Error: slurp is required for window selection${NC}"
        echo -e "${YELLOW}Install with: sudo pacman -S slurp${NC}"
        exit 1
    fi

    echo -e "${BLUE}Click on the window to record...${NC}"

    local geometry
    if command -v swaymsg &> /dev/null; then
        geometry=$(swaymsg -t get_tree | jq -r '.. | select(.pid? and .visible?) | .rect | "\(.x),\(.y) \(.width)x\(.height)"' | slurp -f "%x,%y %wx%h")
    else
        geometry=$(slurp 2>/dev/null)
    fi

    if [[ -z "$geometry" ]]; then
        echo -e "${RED}Window selection cancelled${NC}"
        exit 1
    fi

    local filename
    filename=$(generate_filename "window")

    start_recording "$geometry" "$filename" "window recording"
}
        
stop_recording() {
    if ! is_recording; then
        echo -e "${YELLOW}No recording in progress${NC}"
        exit 0
    fi

    local pid
    pid=$(cat "$PID_FILE")

    echo -e "${BLUE}Stopping recording...${NC}"

    kill -INT "$pid" 2>/dev/null

    local count=0
    while kill -0 "$pid" 2>/dev/null && [[ $count -lt 10 ]]; do
        sleep 1
        ((count++))
    done

    if kill -0 "$pid" 2>/dev/null; then
        kill -KILL "$pid" 2>/dev/null
    fi

    if [[ -f "$STATUS_FILE" ]]; then
        local start_time filename
        start_time=$(sed -n '2p' "$STATUS_FILE")
        filename=$(sed -n '4p' "$STATUS_FILE")
        local duration=$(($(date +%s) - start_time))

        echo -e "${GREEN}Recording stopped!${NC}"
        echo -e "${BLUE}Duration: ${duration}s${NC}"
        echo -e "${BLUE}File: $filename${NC}"

        if [[ -f "$filename" ]]; then
            local size
            size=$(du -h "$filename" | cut -f1)
            echo -e "${BLUE}Size: $size${NC}"
        fi
    else
        echo -e "${GREEN}Recording stopped!${NC}"
    fi

    cleanup_files
}

show_status() {
    if ! is_recording; then
        echo '{"text": "", "class": "idle", "tooltip": "Not recording"}'
        return
    fi

    if [[ -f "$STATUS_FILE" ]]; then
        local start_time description
        start_time=$(sed -n '2p' "$STATUS_FILE")
        description=$(sed -n '3p' "$STATUS_FILE")

        local duration=$(($(date +%s) - start_time))
        local mins=$((duration / 60))
        local secs=$((duration % 60))

        local time_str
        if [[ $mins -gt 0 ]]; then
            time_str=$(printf "%dm%02ds" $mins $secs)
        else
            time_str=$(printf "%ds" $secs)
        fi

        echo "{\"text\": \"ðŸ”´ $time_str\", \"class\": \"recording\", \"tooltip\": \"Recording $description\"}"
    else
        echo '{"text": "ðŸ”´ REC", "class": "recording", "tooltip": "Recording in progress"}'
    fi
}

case "${1:-help}" in
    "region")
        record_region
        ;;
    "monitor")
        record_monitor
        ;;
    "window")
        record_window
        ;;
    "stop")
        stop_recording
        ;;
    "status")
        show_status
        ;;
    "help"|*)
        show_help
        ;;
esac
